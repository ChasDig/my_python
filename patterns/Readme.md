# Паттерны проектирования:
**Определение**: типовое, повторно используемое решение часто встречающейся проблемы в архитектуре программного 
обеспечения. 

### Порождающие(Creational) - управление созданием объектов:
- **[Singleton](creational/singleton/singleton.py)** — это порождающий паттерн проектирования, который гарантирует, 
что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

- **[Factory](creational/factory/factory.py)** — это порождающий паттерн проектирования, который предназначен 
для случаев, когда требуется создать сложный объект, состоящий из других объектов, 
причем все составляющие объекты принадлежат одному "семейству". 
Предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, 
не специфицируя их конкретных классов.

- **[Builder](creational/builder/builder.py)** — это порождающий паттерн проектирования, аналогичен паттерну 
**Factory** в том смысле, что оба предназначены для создания сложных объектов, составленных из других объектов. 
Но отличается тем, что не только предоставляет методы для построения сложного объекта, но и хранит внутри себя его 
полное представление.

- **[Prototype](creational/prototype/prototype.py)** — это порождающий паттерн проектирования, задает виды 
создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования этого прототипа.


### Структурные(Structural) - организуют структуру классов и объектов, организацию между ними:
- **[Adapter](structural/adapter/adapter.py)** — это структурный паттерн проектирования, который позволяет объектам с 
несовместимыми интерфейсами работать вместе.

- **[Facade](structural/facade/facade.py)** — это структурный паттерн проектирования, который предоставляет простой интерфейс к 
сложной системе классов, библиотеке или фреймворку (ограничивая изначальную функциональность используемых систем, мы 
определяем только то, что требуется и то, как этому требуется функционировать).

- **[Decorator](structural/decorator/decorator.py)** — это структурный паттерн проектирования, который позволяет динамически 
добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

- **[Bridge](structural/bridge/bridge.py)** — это структурный паттерн проектирования, который разделяет один или несколько классов 
на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.


### Поведенческие(Behavioral) - описывают, как объекты взаимодействуют и распределяют обязанности:
- **[Iterator](behavioral/iterator/iterator.py)** — это поведенческий паттерн проектирования, который даёт возможность 
последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

- **[Chain of responsibility](behavioral/chain_of_responsibility/chain_of_responsibility.py)** — это поведенческий 
паттерн проектирования, предназначен, для того чтобы разорвать связь между отправителем запроса и получателем, 
который этот запрос обрабатывает. Вместо непосредственного вызова одной функции из другой первая функция отправляет 
запрос цепочке получателей. Первый получатель в цепочке может либо обработать запрос и прервать 
цепочку (не передавая запрос дальше), либо передать запрос следующему получателю. У второго получателя есть 
такой же выбор и так далее, пока запрос не дойдет до последнего получателя (который может отбросить запрос или 
возбудить исключение).

- **[Mediator](behavioral/mediator/mediator.py)** — это поведенческий паттерн проектирования, который 
инкапсулирует взаимодействия между другими объектами. Это позволяет осуществлять взаимодействия между объектами, 
которые ничего не знают друг о друге.

- **[Strategy](behavioral/strategy/strategy.py)** — это поведенческий паттерн проектирования, который 
определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.
Стратегия позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.


# Антипаттерны проектирования:
**Определение**: реализация, код которой менее поддерживаемый, менее читаемый и более подверженный ошибкам 
(решение - рефакторинг).

- **Длинный метод (Long Method)**:
- - Проблема: Метод выполняет слишком много операций и занимает много строк кода.

- **Цепочка вызовов (Message Chains)**:
- - Проблема: Длинные цепочки вызовов методов через несколько объектов.

- **Длинный список параметров (Long Parameter List)**:
- - Проблема: Функция принимает слишком много параметров.

- **Комментарии (Comments)**:
- - Проблема: Чрезмерное использование комментариев вместо понятного кода.

- **Дублирование кода (Duplicate Code)**:
- - Проблема: Одинаковый или очень похожий код в нескольких местах.

- **Большой класс (Large Class)**:
- - Проблема: Класс имеет слишком много методов и полей.

- **Мертвый код (Dead Code)**:
- - Проблема: Код, который никогда не выполняется.

- **Ленивый класс (Lazy Class)**:
- - Проблема: Класс, который делает слишком мало.

- **Посредник (Middle Man)**:
- - Проблема: Класс, который только делегирует вызовы другому классу.

- **Завистливые функции (Feature Envy)**:
- - Проблема: Метод больше использует данные другого класса, чем своего собственного.

- **Неуместная близость (Inappropriate Intimacy)**:
- - Проблема: Классы знают слишком много о внутреннем устройстве друг друга.
