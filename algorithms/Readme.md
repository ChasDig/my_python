## Алгоритмы:

**Big-O** - математическая нотация, которая описывает **верхнюю границу времени выполнения алгоритма или объёма 
используемой памяти** в зависимости от размера входных данных (**N**).
По-простому - как быстро растёт время работы алгоритма при увеличении входных данных.

**Рекурсия** – когда функция вызывает саму себя. Логика рекурсивной функции как правило состоит из двух ветвей. Длинная 
ветвь вызывает эту же функцию с другими параметрами, чтобы накопить результат. Короткая ветвь определяет критерий 
выхода из рекурсии.

**Граф** - моделирует набор связей. Они состоят из узлов и ребер. Узлы напрямую соединенные с другими узлами 
называются соседями.
Бывают направленные и ненаправленные, взвешенные и невзвешенные:
- В направленном графе есть стрелки, а отношения действуют в направлении стрелки 
(А -> Б, значит Б - сосед А, а А - родитель Б).
- В ненаправленном графе стрелок нет, а отношение идет в обе стороны.

**Очередь и стек**:
- Очередь FIFO (first in first out).
- Стек LIFO (last in first out).

**Дерево** - особая разновидность графа, в котором нет ребер, которые указывают в обратном направлении:
- Корень (начальный узел).
- Дочерние узлы (потомки).
- Листья (узлы без потомков).

Основные типы деревьев:
- Бинарное дерево (каждый узел имеет ≤ 2 потомков).
- Двоичное дерево поиска (BST) (левые потомки ≤ родитель ≤ правые потомки).
- АВЛ-дерево / Красно-чёрное дерево (самобалансирующиеся BST).
- Префиксное дерево (Trie) (для хранения строк).
- Дерево отрезков (для запросов на диапазонах).

Основные алгоритмы на деревьях:
- Обходы (DFS, BFS):
- In-order (левый → корень → правый).
- Pre-order (корень → левый → правый).
- Post-order (левый → правый → корень).

**Жадные алгоритмы (Greedy Algorithms)** - используются когда вычисление точного решения занимает слишком много 
времени или когда высокая точность не требуется. Эффективность приближенного алгоритма оценивается по:
- быстроте
- близости полученного решения к оптимальному

Ключевые особенности:
- Не всегда дают глобально оптимальный результат.
- Работают быстро, но требуют доказательства корректности.
- Используются, когда задача обладает свойством жадного выбора (локальный оптимум ведёт к глобальному).

Примеры задач:
- Задача о размене монет (минимальное количество монет).
- Задача о расписании (выбор непересекающихся интервалов).
- Алгоритм Дейкстры (для кратчайшего пути без отрицательных рёбер).
- Алгоритм Хаффмана (оптимальное кодирование).

**NP-полные задачи** — это "граница" между тем, что мы можем решать быстро, и тем, что пока не умеем. 
Они помогают понимать пределы вычислительной сложности.

Основные понятия:
- **P-задачи** — проблемы, которые можно быстро решить (за полиномиальное время, например, O(n²)).
Пример: Сортировка массива, поиск в словаре.

- **NP-задачи** — проблемы, где решение можно быстро проверить, но неизвестно, можно ли его быстро найти.
Пример: Задача коммивояжёра (проверить маршрут легко, но найти оптимальный — сложно).

- **NP-полные задачи** — это "самые сложные" задачи в классе NP. Если найдётся быстрый алгоритм для хотя бы 
одной из них, то все NP-задачи можно будет решать быстро.

Признаки:
- ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа;
- формулировка ~все комбинации х~ часто указывает на NР-полноту задачи;
- вам приходится вычислять все возможные варианты Х, потому что задачу невозможно разбить на меньшие подзадачи? 
Такая задача может оказаться NР-полной;
- если в задаче встречается некоторая последовательность 
(например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, 
она может оказаться NР-полной;
- если в задаче встречается некоторое множество (например, множество радиостанций) и задача не имеет простого решения, 
она может оказаться NР-полной;
- можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае ваша 
задача определенно является NР-полной.

**Динамическое программирование (Dynamic Programming, DP)** - метод решения сложных задач путём разбиения их на более 
простые подзадачи, с запоминанием промежуточных результатов (мемоизация или табуляция), чтобы избежать повторных 
вычислений (обычно табуляция - построение таблицы).

Ключевые особенности:
- Оптимальная подструктура (оптимальное решение задачи зависит от оптимальных решений подзадач).
- Перекрывающиеся подзадачи (одни и те же подзадачи решаются многократно).
- Используется для задач оптимизации (например, "найти минимум/максимум").

Примеры задач:
- Числа Фибоначчи.
- Задача о рюкзаке.
- Наибольшая общая подпоследовательность (LCS).
- Алгоритм Флойда-Уоршелла (кратчайшие пути в графе).


### Основные правила расчёта Big-O:
1. Игнорируем константы
- O(5n) → O(n)
- O(2n² + 3) → O(n²)
❌ Неважно: O(1000000) → O(1) (константное время).

2. Учитываем только самый быстрорастущий член
- O(n³ + n² + n) → O(n³)
- O(2ⁿ + n⁵) → O(2ⁿ)

3. Разные входы — разные переменные
Если алгоритм зависит от двух разных размеров (n и m), то:
- O(n + m)
- O(n * m)

4. Рекурсия
Для рекурсивных алгоритмов учитываем:
- Глубину рекурсии (стек вызовов).
- Количество операций на каждом уровне.


### Основные сложности алгоритмов (от быстрых к медленным):
| Нотация       | Название                | Пример                          | Когда встречается                 |
|---------------|-------------------------|---------------------------------|-----------------------------------|
| **O(1)**      | Константное время       | Доступ по индексу в массиве      | Хеш-таблицы (`dict`, `set`)       |
| **O(log n)**  | Логарифмическое время   | Бинарный поиск                   | Алгоритмы "разделяй и властвуй"   |
| **O(n)**      | Линейное время          | Линейный поиск                   | Один цикл по данным               |
| **O(n log n)**| Линеарифметическое время| Быстрая сортировка (quicksort)    | Эффективные сортировки            |
| **O(n²)**     | Квадратичное время      | Пузырьковая сортировка           | Два вложенных цикла               |
| **O(n³)**     | Кубическое время        | Перебор всех троек               | Три вложенных цикла               |
| **O(2ⁿ)**     | Экспоненциальное время  | Перебор всех подмножеств          | Рекурсия без мемоизации           |
| **O(n!)**     | Факториальное время     | Перебор всех перестановок         | Задача коммивояжёра (brute-force) |

#### Дополнительные пояснения:
- **O(1)** - Самый быстрый вариант (например, доступ к элементу словаря)
- **O(log n)** - Характерен для алгоритмов, которые отбрасывают половину вариантов на каждом шаге
- **O(n log n)** - Практический предел для эффективных алгоритмов сортировки
- **O(2ⁿ)** и **O(n!)** - Становятся непрактичными уже при относительно небольших n (n > 20-30)


### Виды алгоритмов:
#### Алгоритмы поиска:
- **[Линейный поиск](linear_search/linear_search.py)** — алгоритм поиска, который последовательно проверяет каждый элемент списка 
(**сложность O(N)**)

- **[Бинарный поиск](binary_search/binary_search.py)** — алгоритм поиска в отсортированном массиве (на каждом шаге 
делит массив пополам, сложность **O(logN)**)

#### Алгоритмы сортировки: 
- **[Сортировка пузырьком](bubble_sort/bubble_sort.py)** — алгоритм сортировки, который многократно проходит по списку, 
сравнивая соседние элементы (сложность O(N^2))

- **[Быстрая сортировка](quick_sort/quick_sort.py)** — эффективный алгоритм сортировки, использующий стратегию 
"разделяй и властвуй" (сложность O(N log N) в среднем случае, O(N^2) в худшем)

#### Алгоритмы на графах:
- **[Алгоритм Дейкстры](dijkstra_algorithm/dijkstra_algorithm.py)** — алгоритм для нахождения кратчайшего пути между 
вершинами в графе (использует приоритетную очередь для выбора вершины с минимальным текущим расстоянием).
Сложность:
- - с кучей (priority queue): O((V + E) log V), где V — вершины, E — рёбра.
- - для плотных графов: O(V²).

#### Динамическое программирование:
- **[Число Фибоначчи](fibonacci/fibonacci.py)** - рекуррентная последовательность, где каждое число равно сумме двух 
предыдущих: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2). Сложность - **O(n)**.

#### Жадные алгоритмы:
- **[Задача о размене монет](coin_change/coin_change.py)** - найти минимальное количество монет, сумма которых равна 
заданной величине. Сложность (жадный алгоритм, для канонических систем): O(n).

#### Деревья и алгоритмы на них:
- **[Обход дерева (In-order, Pre-order, Post-order)](coin_change/coin_change.py)** - порядок посещения узлов дерева:
- - In-order (левый → корень → правый): для BST даёт отсортированную последовательность.
- - Pre-order (корень → левый → правый): копирование структуры дерева.
- - Post-order (левый → правый → корень): удаление дерева.
Сложность: O(n) (каждый узел посещается один раз).

#### "Разделяй и властвуй":
- **[Алгоритм Евклида](euclidean_algorithm/euclidean_algorithm.py)** — алгоритм для нахождения наибольшего общего 
делителя (НОД) двух чисел (сложность O(log min(a, b)))
